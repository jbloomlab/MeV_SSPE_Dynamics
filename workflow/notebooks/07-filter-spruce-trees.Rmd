---
title: "7. Analyze Spruce Output"
author:
    - "Will Hannon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
---

The goal of this notebook is to visualize the phylogenetic relationship of the haplotypes identified in the previous notebooks. I'll read in the tree's from `SPRUCE` as implemented by `MACHINA` and make a nicely formatted tree where branch length corresponds to mutations. 

```{r Setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = FALSE)
```

```{r Required Packages, message=FALSE, warning=FALSE, echo=FALSE}

## ==== Install Required Packages ==== ##

## List of all packages needed
packages = c("tidyverse", "foreach", "emdbook", "RColorBrewer", "data.table", "ggnetwork", "network")

## Packages loading
invisible(lapply(c(packages), library, character.only = TRUE))

```

```{r Inputs, echo=T}

## ==== File paths input data ==== ##

if (exists("snakemake")) {

  # Data from lofreq and varscan labeled with subclonal haplotypes
  updated.data = snakemake@input[["1"]]
  # Phylogeny 
  phylo.data =  snakemake@input[["2"]]

} else {

  # Data from lofreq and varscan labeled with subclonal haplotypes
  updated.data = "../../results/variants/validated_variants.csv"

  # Spruce 
  spruce.data = "../../results/variants/spruce_output.tsv"
  
  # Counts of all reads bridging pairs of SNP positions
  bridging.data = "../../results/bridging/bridging_reads.csv"

}

```

## SPRUCE Trees

A set of phylogenetic relationships were fit to the data using the algorithm `SPRUCE`. We'll visualize these possible trees below. Ultimately, the goal is filter these based on bridging reads. 

```{r Read Spruce, echo=T}

# Code adapted from Alison Feder #

# Read in the output from Machina
machina.output = readLines( "../../results/variants/spruce_output.tsv")

# Process the output trees into edges
treenum = NA
tree.df = foreach(i = 1:length(machina.output), .combine = "rbind") %do% {
    toParse = machina.output[i]
    if(grepl("^#", toParse)){ return(NULL) }
    if(grepl("#trees", toParse)){ return(NULL) }
    if(grepl("#edges", toParse)){
        treenum = gsub("[0-9]+ \\#edges, ", "", toParse)
        return(NULL)
    }
    tibble(toParse) %>%
      separate(toParse, into = c("from", "to"), sep = " ") %>%
        mutate(tree = treenum)
}
tree.df = tree.df %>%
  mutate(treenum = as.numeric(gsub("tree ", "", tree)))

```

Let's visualize All of these trees below. 

```{r Color Palletes, echo=F}

# Make a color scheme for the haplotypes
## Genome-1
genome.1.haplotypes = c( "cluster 1", "cluster 2", "cluster 3", "cluster 4", "cluster 5", "cluster 7", "cluster 8", "genome 1", "genome 01")
genome.1.colors = brewer.pal(length(genome.1.haplotypes), "Blues")
names(genome.1.colors) = genome.1.haplotypes

## Genome-2
genome.2.haplotypes = c("cluster 9", "cluster 10", "cluster 11", "cluster 12", "cluster 13", "genome 2")
genome.2.colors = brewer.pal(length(genome.2.haplotypes), "YlOrRd")
names(genome.2.colors) = genome.2.haplotypes

## Cluster 6
cluster.6.haplotype = c("cluster 6")
cluster.6.color = brewer.pal(8, "Purples")[8]
names(cluster.6.color) = cluster.6.haplotype

## Combine
haplotype.colors = c(genome.1.colors, genome.2.colors, cluster.6.color)
# names(haplotype.colors) = gsub(" ", "_", names(haplotype.colors ))
haplotype.colors = c(haplotype.colors , "Anc" = "black")
# cluster 1 is too light
haplotype.colors['cluster 1'] = "#bdbebf"

## Set the Compartment Colors 
# Frontal Cortex
FCs = c("Frontal Cortex 1", "Frontal Cortex 2", "Frontal Cortex 3")
FCs.colors = brewer.pal(length(FCs), "Greens")
names(FCs.colors) = FCs
# Internal Compartments
Internal = c("Cerebellum Nucleus", "Cerebellum", "Midbrain", "Internal Capsule", "Brain Stem", "UBS", "Hippocampus")
Internal.colors = brewer.pal(length(Internal), "YlOrRd")
names(Internal.colors) = Internal
# Other Lobes
Other =  c("Occipital Lobe", "Temporal Lobe", "Parietal Lobe")
Other.colors = brewer.pal(length(Other), "Blues")
names(Other.colors) = Other
# Combine
Compartment.cols = c(FCs.colors, Internal.colors, Other.colors)
names(Compartment.cols) = gsub(" ", "_", names(Compartment.cols))

```

```{r Spruce Trees, message=F, warning=F, fig.align='center', fig.width=25, fig.height=25, echo=T}

names(haplotype.colors) = gsub(" ", "_", names(haplotype.colors ))
ggnetwork(network(tree.df, multiple = TRUE), by = "treenum")  %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
    theme_blank() +
    geom_edges(curvature = 0.15) +
    geom_nodes(aes(fill = vertex.names), size = 10, pch = 21) +
    scale_fill_manual(values = haplotype.colors) +
    geom_nodetext(aes(y = y - 0.06, label =  vertex.names), color = "black", size = 2) +
    facet_wrap(~treenum) +
    theme(legend.position = "none")

```

There are total of `r length(unique(tree.df$treenum))` trees that fit to the data. Below, I'll use bridging reads to test the edges for these trees and filter them down to a final plausible set of trees. 

## Filter SPRUCE Trees

First, we already have some knowledge about whether a cluster is descended from either `Genome 1` or ` Genome 2`. Let's filter out trees based on this information.

```{r Genotype Background Violations, echo = T}

cluster.backgrounds = read_csv(updated.data, show_col_types = F) %>% 
  select(Haplotype = Haplotype_Name, Background) %>% 
  distinct() %>% 
  filter(!Haplotype %in% c("both", "subclonal")) %>% 
  add_row(Haplotype = "Anc", Background = "Anc")
  

trees = unique(tree.df$tree)
trees.with.genotype.violations = c()
for (tree.name in trees) {
  
  # Get the edges from this tree
  tree.edges = tree.df %>% 
    filter(tree == tree.name) %>% 
    select(from, to)
  
  # Check if there is a violation in any of the edges
  for (i in 1:nrow(tree.edges)) {
    # Get the edge
    edge = tree.edges[i,]
    # Get the cluster names 
    from = str_replace_all(edge$from, "_", " ")
    to = str_replace_all(edge$to, "_", " ")
    # Get backgrounds 
    from.background = cluster.backgrounds %>% 
      filter(Haplotype == from) %>% 
      pull(Background)
    to.background = cluster.backgrounds %>% 
      filter(Haplotype == to) %>% 
      pull(Background)
    
    if (from == "genome 01" & to.background != "genome-1") {
      print(paste("Violation in", tree.name, " -- from:", from, "to:", to))
      trees.with.genotype.violations = c(trees.with.genotype.violations, tree.name)
    } else if (from == "genome 2" & to.background != "genome-2") {
      print(paste("Violation in", tree.name, " -- from:", from, "to:", to))
      trees.with.genotype.violations = c(trees.with.genotype.violations, tree.name)
    } else if (from.background == "genome-1" & to.background == "genome-2") {
      print(paste("Violation in", tree.name, " -- from:", from, "to:", to))
      trees.with.genotype.violations = c(trees.with.genotype.violations, tree.name)
    } else if (from.background == "genome-2" & to.background == "genome-1") {
      print(paste("Violation in", tree.name, " -- from:", from, "to:", to))
      trees.with.genotype.violations = c(trees.with.genotype.violations, tree.name)
    }
  }
}

trees.with.genotype.violations = unique(trees.with.genotype.violations)

```

There are `r length(trees.with.genotype.violations)` of `r length(unique(tree.df$treenum))` total trees that violate the bridging read support for a given background (`Genome 1` or `Genome 2`).

The remaining `r length(unique(tree.df$treenum)) - length(trees.with.genotype.violations)` trees are still plausible. Can we determine which of these are more likely?

## Check Valid Trees

To determine if the remaining tress fit our data, I'll see if there are cluster relationships (i.e. the tree predicts that one cluster is descended from another) that we can either confirm or disprove using our bridging reads over pairs of SNPs. 

To do this, I'll use the same approach that was used to assign clusters to either `Genome 1` or `Genome 2`. However, in this version, I'll be testing whether a cluster is descended from another cluster, or if they arose independently. 

```{r Valid Trees, echo=T, fig.align='center', fig.width=8, fig.height=4}

valid.trees.df = tree.df %>% 
  filter(!tree %in% trees.with.genotype.violations)

ggnetwork(network(valid.trees.df, multiple = TRUE), by = "treenum")  %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
    theme_blank() +
    geom_edges(curvature = 0.15) +
    geom_nodes(aes(fill = vertex.names), size = 10, pch = 21) +
    scale_fill_manual(values = haplotype.colors) +
    geom_nodetext(aes(y = y - 0.06, label =  vertex.names), color = "black", size = 2) +
    facet_wrap(~treenum) +
    theme(legend.position = "none")  

```

For this approach, we need the individual mutations and their frequecy, the mean frequency of every cluster in each tissue sample, and the bridging reads. 

```{r Format Data, echo = T}

# Import the SNPs that were phased in the previous notebook 
updated.df = read_csv(updated.data, show_col_types = FALSE)

# Get the haplotype names for each SNP
haplotypes.SNP.label = updated.df %>% 
  select(Haplotype = Haplotype_Name, SNP) %>% 
  distinct()

# Expand the haplotyped SNPs to have records for all tissues
expanded.df = updated.df %>% 
  select(SNP, Tissue, AF) %>% 
  pivot_wider(names_from = "Tissue", values_from = "AF", values_fill = 0) %>% 
  pivot_longer(cols = !SNP, names_to = "Tissue", values_to = "AF") %>% 
  left_join(., select(updated.df, c("SNP", "Tissue", "DP",)), by = c("SNP", "Tissue")) %>% 
  mutate(DP = if_else(is.na(DP), 0, DP)) %>% 
  left_join(., distinct(select(updated.df, c("SNP", "POS"))), by = c("SNP")) %>% 
  left_join(., haplotypes.SNP.label, by = "SNP") 

# Calculate the mean haplotype frequency across each tissue
haplotype.mean = expanded.df %>% 
  group_by(Tissue, Haplotype) %>% 
  summarize(AF = mean(AF))

# Import the reads that bridge all pairs of SNPs for the multinomial approach
bridging.df = read_csv(bridging.data, show_col_types = FALSE)

# Cutoff for minimum bridging depth
min.bridging.depth = 10
  
# Labels for the haplotypes
haplotype.labels = updated.df %>% 
  select(POS, Haplotype = Haplotype_Name) %>% 
  distinct()

# Some positions are in more than on haplotype, filter these
excluded.pos = haplotype.labels %>% 
  group_by(POS) %>% 
  count() %>% 
  filter(n > 1) %>% 
  pull(POS)

# Filter the bridging read pairs 
labled.bridging.df = bridging.df %>% 
  # Add the snp_1 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_1 = POS, hap_1 = Haplotype)) %>% 
  # Add the snp_2 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_2 = POS, hap_2 = Haplotype)) %>% 
  # Filter based one some minimum bridging depth cutoff
  filter((`00` + `01` + `10` + `11`) > min.bridging.depth) %>% 
  # TODO calculate bridging reads by SNP rather than position 
  filter(!((snp_1 %in% excluded.pos) | (snp_2 %in% excluded.pos)))


```

Let's check if there are cluster relationships that we can confirm or deny by read support.

```{r Check Valid Trees, echo = T}

cluster.test.df = data.frame()

for (tree.name in unique(valid.trees.df$tree)) {
  
  # Get the edges from this tree
  tree.edges = valid.trees.df %>% 
    filter(tree == tree.name) %>% 
    select(from, to)
  
  # Check the evidence for nesting between clusters that are linked on the tree
  for (i in 1:nrow(tree.edges)) {
    # Get the edge
    edge = tree.edges[i,]
    
    # Get the cluster names 
    from = str_replace_all(edge$from, "_", " ")
    to = str_replace_all(edge$to, "_", " ")
    
    # Check if it's a cluster is predicted to descend from another cluster
    if(str_detect(from, "cluster") & str_detect(to, "cluster")) {
      
      # Status statement
      print(paste("Checking if", to, "is descended from", from, "for", tree.name))
      
      # Filter the bridging reads for overlaps between the clusters being tested
      snp.pairs = labled.bridging.df %>%  
        filter((hap_1 == to & hap_2 == from) | (hap_1 == from & hap_2 == to)) %>% 
        select(snp_1, snp_2) %>% 
        distinct()
      
      # Check if there are any bridging to test
      if (nrow(snp.pairs) == 0) { 
        # There aren't any bridging reads overlapping these SNPs
        linkage.information = "no information"
        print(linkage.information)
        # Write to a row
        row = tibble(snp_1 = NA, snp_2 = NA,
               hap_1 = NA, hap_2 = NA,
               from = from, to = to,
               lik_related = NA, lik_unrelated = NA,
               tree = tree.name, relationship = linkage.information)
        cluster.test.df = rbind(cluster.test.df, row)
        # Go to the next haplotypes
        next
      }

      for (i in 1:nrow(snp.pairs)) {
        
        # Get the positions of the SNPs
        snp.1 = snp.pairs[i,]$snp_1
        snp.2 = snp.pairs[i,]$snp_2
        
        # Print the SNP overlaps being checked 
        print(paste("Checking SNPs:", snp.1, "v.", snp.2))
        
        # Get the cluster names
        snp.1.cluster = haplotype.labels %>% 
          filter(POS == snp.1) %>% 
          pull()
        snp.2.cluster = haplotype.labels %>% 
          filter(POS == snp.2) %>% 
          pull()
        
        # Get the overlaps
        overlaps = labled.bridging.df %>% 
          filter(snp_1 == snp.1, snp_2 == snp.2)
        
        # Iterate over each tissue in the overlaps
        tissue.test = foreach(i = 1:nrow(overlaps), .combine = "rbind") %do% {
          
          # Get the tissue
          tissue = overlaps[i, ]$Tissue
          
          # Get the cluster frequencies
          f.anc = max(0, (haplotype.mean %>% filter(Haplotype == from, Tissue == tissue))$AF)
          f.dec = max(0, (haplotype.mean %>% filter(Haplotype == to, Tissue == tissue))$AF)
          
          # Overlaps to test in this tissue
          toTest = overlaps %>%
            filter(Tissue == tissue)
              
          # x11 refers to the number of reads overlapping both
          x11 = toTest$`11`
          if (snp.1.cluster == from) {
            # x10 is the number of reads overlapping just descendant
            x10 = toTest$`10`
            # x01 is the number of reads overlapping just ancestor
            x01 = toTest$`01`
          } else {
            # x10 is the number of reads overlapping just descendant (01 in data)
            x10 = toTest$`01`
            # x01 is the number of reads overlapping just ancestor (10 in data)
            x01 = toTest$`10`
          }
          # x00 is the number of reads overlapping neither
          x00 = toTest$`00`
          
          # There are two possibilities
          # 1: The inferred descendant does arise on the ancestor 
          # 2: The inferred descendant and ancestor arose independently 
          
          error = 0.01
          
          # Descendant and ancestor should be all of the descendant reads
          f11 = (f.dec + error)/(1 + 4*error)
          # Only the descendant should be just the error
          f10 = (0 + error)/(1 + 4*error)
          # Only the ancestor should be the frequency of the ancestor minus the descendant
          f01 = max(0 + error, (f.anc - f.dec + error))/(1 + 4*error) 
          # The remainder should be neither
          f00 = 1 - f11 - f10 - f01  
          
          # What is the probability of observing these counts given the haplotypes are nested?
          lik.nested = -dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T) 
          
          # We should not see any reads with both
          f11 = (0 + error)/(1 + 4*error)
          # Just the ancestor 
          f01 = (f.anc + error)/(1 + 4*error)
          # Just the descendant
          f10 = (f.dec + error)/(1 + 4*error)
          # The remainder should be the subtraction
          f00 = 1 - f11 - f01 - f10
          
          # What is the probability of observing these counts given the haplotypes are not nested?
          lik.independant = -dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T)
          
          # Results
          results = c(lik.nested, lik.independant)
        }

        AICs = 2 * apply(tissue.test, 2, sum, na.rm = TRUE)
        AIC.min = min(AICs)
        rel.related = exp((AIC.min - AICs[1])/2)
        rel.unrelated = exp((AIC.min - AICs[2])/2)
        lik.related = rel.related/(rel.related + rel.unrelated)
        lik.unrelated = rel.unrelated/(rel.related + rel.unrelated)
        
        linkage.information = c("Nesting", "Non-nesting", "neither")[c(lik.related > 0.95, lik.unrelated > 0.95,
                                                                       lik.related < 0.95 & lik.unrelated < 0.95)]
        print(linkage.information)
        # Write to a row
        row = tibble(snp_1 = snp.1, snp_2 = snp.2,
               hap_1 = snp.1.cluster, hap_2 = snp.2.cluster,
               from = from, to = to,
               lik_related = lik.related, lik_unrelated = lik.unrelated,
               tree = tree.name, relationship = linkage.information)
        
        cluster.test.df = rbind(cluster.test.df, row)

      }
      
    }

  }
  
}

```
It looks like we can confidently say that `cluster 7` is **not** descended from `cluster 5`. This means that can rule out all but a single single valid tree. 

```{r Valid Tree, echo = T}

# Trees with 'non-nesting' clusters are invalid
trees.with.cluster.violations = cluster.test.df %>%
  filter(relationship == 'Non-nesting') %>% 
  pull(tree) %>% 
  unique()

```

There is only `r length(trees.with.violations)` tree with violations and that's `r trees.with.violations`.

```{r Final Tree, echo=T, fig.align='center', fig.width=4, fig.height=4}

final.tree.df = tree.df %>% 
  filter(!tree %in% c(trees.with.genotype.violations, trees.with.cluster.violations))

ggnetwork(network(final.tree.df, multiple = TRUE), by = "treenum")  %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
    theme_blank() +
    geom_edges(curvature = 0.15) +
    geom_nodes(aes(fill = vertex.names), size = 10, pch = 21) +
    scale_fill_manual(values = haplotype.colors) +
    geom_nodetext(aes(y = y - 0.06, label =  vertex.names), color = "black", size = 2) +
    facet_wrap(~treenum) +
    theme(legend.position = "none")  

```
