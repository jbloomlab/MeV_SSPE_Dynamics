---
title: "4. Assign Haplotype Backgrounds"
author:
    - "Will Hannon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
---

The goal of this notebook is to establish a method to genotype SNPs as either belonging to `Genome 1` or to `Genome 2`. 

```{r Setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = FALSE)
```

```{r Required Packages, message=FALSE, warning=FALSE, echo=FALSE}

## ==== Install Required Packages ==== ##

## List of all packages needed
packages = c("tidyverse", "foreach", "emdbook")

## Packages loading
invisible(lapply(c(packages), library, character.only = TRUE))

```

```{r Inputs, echo=T}

## ==== File paths input data ==== ##

if (exists("snakemake")) {
  # Data from lofreq and varscan labeled with subclonal haplotypes
  updated.data = snakemake@params[["incsv"]]
  # Annotations for MeV genes
  annotations.filepath = snakemake@params[["annotations"]]
  # Counts of SNPs on reads belonging to genome-1 or genome-2
  g1.g2.reads.data = snakemake@input[[1]]
  # Counts of all reads bridging pairs of SNP positions
  bridging.reads.data = snakemake@input[[2]]

} else {
  # Data from lofreq and varscan labeled with subclonal haplotypes
  updated.data = "../../results/variants/clustered_variants.csv"
  # Annotations for MeV genes
  annotations.filepath = "../../config/annotations.csv"
  # Counts of SNPs on reads belonging to genome-1 or genome-2
  g1.g2.reads.data = "../../results/bridging/genotyped.csv"
  # Counts of all reads bridging pairs of SNP positions
  bridging.reads.data = "../../results/bridging/bridging_reads.csv"
}

```

```{r Outputs, echo=T}

## ==== File paths output data ==== ##

# Path to save the results
if (exists("snakemake")) {
  output.path = snakemake@params[["outcsv"]]
} else {
  output.path = "../../results/variants/assigned_variants.csv"
}

```

```{r Import and Format Data, message=F, echo = T}

# Import the SNPs that were phased in the previous notebook 
updated.df = read_csv(updated.data, show_col_types = FALSE)

# Get the haplotype names for each SNP
haplotypes.label = updated.df %>% 
  select(Haplotype, SNP) %>% 
  distinct()

# Expand the haplotyped SNPs to have records for all tissues
expanded.df = updated.df %>% 
  select(SNP, Tissue, AF) %>% 
  pivot_wider(names_from = "Tissue", values_from = "AF", values_fill = 0) %>% 
  pivot_longer(cols = !SNP, names_to = "Tissue", values_to = "AF") %>% 
  left_join(., select(updated.df, c("SNP", "Tissue", "DP",)), by = c("SNP", "Tissue")) %>% 
  mutate(DP = if_else(is.na(DP), 0, DP)) %>% 
  left_join(., distinct(select(updated.df, c("SNP", "POS"))), by = c("SNP")) %>% 
  left_join(., haplotypes.label, by = "SNP") 

# Calculate the mean haplotype frequency across each tissue
haplotype.mean = expanded.df %>% 
  group_by(Tissue, Haplotype) %>% 
  summarize(AF = mean(AF))

# Import the counts of SNPs on genome-1 and genome-2 backgrounds for the CliqueSNV approach 
genotyping.df = read_csv(g1.g2.reads.data, show_col_types = FALSE) %>% 
  select(!AF) %>% 
  rename(total = DP, 
         var = OBSV) %>% 
  mutate(genotype = if_else(genotype == "genome-1", "g1", "g2")) %>% 
  pivot_wider(names_from = genotype,
              values_from = c(total, var), 
              names_sep = "_", 
              values_fill = 0) %>% 
  left_join(., haplotypes.label, by = "SNP") 

# Import the reads that bridge all pairs of SNPs for the multinomial approach
bridging.df = read_csv(bridging.reads.data, show_col_types = FALSE)

```

## CliqueSNV Approach 

This approach resembles is derived from a part of the [`CliqueSNV`](https://academic.oup.com/nar/article/49/17/e102/6313236) algorithm. It's used to determine if SNPs are linked or forbidden from counts of reads overlapping both SNPs. This is one of two approaches that we'll use to assign the haplotypes to `Genome 1` or `Genome 2`. 

```{r Assign Genotypes for each Tau, echo=T}

# Log-spaced sequence of taus
taus = lseq(0.00001, 1, length.out = 200)

# Minimum significance
min.sig = 0.05

# Minimum number of variant observations? 

# Assign to genome for each value of tau
assignmentsByTau = foreach(tau = taus, .combine = "rbind")%do%{

    allSNPs = genotyping.df %>% 
        gather(cat, count, -POS, -REF, -ALT, -SNP, -Tissue, -Haplotype) %>% 
        separate(cat, into = c("cat", "G"), sep = "_") %>% 
        spread(cat, count) %>% 
        group_by(SNP, G) %>% 
        mutate(linked= pbinom( var, total, tau, lower.tail = FALSE), 
               sig = linked < min.sig/n()) %>% 
        mutate(sig = ifelse(total == 0, NA, sig)) %>% 
        summarize(TissueCount = sum(sig, na.rm = TRUE), .groups = "drop") %>% 
        spread(G, TissueCount) %>% 
        mutate(G1orG2 = ifelse(g1 > 0 & g2 == 0, "G1",
                        ifelse(g2 > 0 & g1 == 0, "G2", 
                        ifelse(g1 > 0 & g2 > 0, "G1/G2", 
                        ifelse(g1 == 0 & g2 == 0, "-", "*"))))) %>% 
        ungroup()


    left_join(genotyping.df, allSNPs, by = "SNP") %>% select( -total_g1, -total_g2, -var_g1, -var_g2) %>% mutate(tau = tau)

}


```

What are the `genome1/2` assignments for each identified haplotype for every value of `tau` between `0.00001` and `1`? 

```{r Assignments for all Haplotypes, warning=F, message=F, fig.align='center', fig.width=18, fig.height=14}

assignment.order = c('G1', 'G2', 'G1/G2', '-')
assignment.colors = c("#307EC2", "#B63F3E", "purple", "darkgrey")
  
assignmentsByTau %>%
  select(-Tissue) %>% 
  unique() %>%
  group_by(G1orG2, Haplotype, tau) %>%
  summarize(n = n()) %>% 
  spread(G1orG2, n) %>%
  gather(type, count, -Haplotype, -tau) %>% 
  mutate(count = ifelse(is.na(count), 0, count)) %>%
  spread(type, count) %>% 
  gather(type, count, -Haplotype, -tau) %>%
  group_by(Haplotype, tau) %>%
  mutate(total = sum(count)) %>% 
  mutate(prop = count/total) %>% 
    ggplot(aes(x = tau, y = prop, col = factor(type, level = assignment.order), group = type)) +
      geom_path(size = 1.5) + 
      scale_x_log10() +
      facet_wrap(~Haplotype) +
      labs(y = "Proportion of SNPs assigned") +  
      scale_color_manual(values = assignment.colors, name = "Genome Assignment") +
      theme_classic() +
      theme(panel.grid.major.y = element_line(colour="grey", linetype="dashed")) +
      theme(legend.position="bottom", legend.box = "horizontal") +
      theme(legend.box.background = element_rect(colour = "black")) +
      theme(text=element_text(size=18)) + 
      theme(plot.title = element_text(hjust = 0.5)) 


```

How does this look for subclonal SNPs? Can we assign most to either `genome-1` or `genome-2`? 

```{r Annotations, message=FALSE, warning=FALSE}

# Import genome annotations
annotations.df = read_csv(annotations.filepath, show_col_types = FALSE)

# Get the interval positions for these genes 
N = annotations.df %>% dplyr::filter(Locus == "N")
P.V.C = annotations.df %>% dplyr::filter(`Protein Name` == "phosphoprotein")
M = annotations.df %>% dplyr::filter(Locus == "M")
F. = annotations.df %>% dplyr::filter(Locus == "F")
H = annotations.df %>% dplyr::filter(Locus == "H")
L = annotations.df %>% dplyr::filter(Locus == "L")

```

```{r Subclonal Assignments, warning=F, message=F, echo = T}

subclonal.assignments = assignmentsByTau %>%
  filter(Haplotype == "subclonal") %>%
  select(-Tissue) %>% 
  unique() %>%
  group_by(G1orG2, SNP, tau) %>%
  summarize(n = n()) %>% 
  spread(G1orG2, n) %>% 
  gather(type, count, -SNP, -tau) %>% 
  mutate(count = ifelse(is.na(count), 0, count)) %>%
  spread(type, count) %>% 
  gather(type, count, -SNP, -tau) %>% group_by(SNP, tau) %>%
  mutate(total = sum(count)) %>% 
  mutate(prop = count/total) %>%
  group_by(SNP) %>%
  filter(type == "G1" | type == "G2") %>% 
  filter(prop > 0) %>%
  select(SNP, type) %>% 
  unique()

```

There isn't much of a difference between the assignment of SNPs to `genome-1` or `genome-2` across the MeV genome. 

```{r Subclonal Assignments Positions, warning=F, message=F, fig.align='center', fig.width=10, fig.height=8}

# Import genome annotations
annotations.df = read_csv(annotations.filepath, show_col_types = FALSE)

# Get the interval positions for these genes 
N = annotations.df %>% dplyr::filter(Locus == "N")
P.V.C = annotations.df %>% dplyr::filter(`Protein Name` == "phosphoprotein")
M = annotations.df %>% dplyr::filter(Locus == "M")
F. = annotations.df %>% dplyr::filter(Locus == "F")
H = annotations.df %>% dplyr::filter(Locus == "H")
L = annotations.df %>% dplyr::filter(Locus == "L")

left_join(subclonal.assignments, genotyping.df) %>%
  select(SNP, type, POS) %>%
  unique() %>% 
  ggplot(aes(x = POS, y = type, col = type)) +
    geom_point(pch = "|", size = 3) +
    labs(x = "Position", y = "Genome")+
    scale_color_manual(values = assignment.colors, name = "Genome Assignment") +
  
    # == Annotations of genes == #
  
    # Nucleoprotein
    annotate("rect", xmin = N$Start-1, xmax = N$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "dodgerblue2", col = "black", size = .1) +
    annotate(geom = "text", x = (N$Stop + N$Start)/2, y = .05, label = "N", size = 8) +
    annotate("rect", xmin = N$Start-1, xmax = N$Stop, ymin = 0, ymax = 2.5 ,
                   alpha = .1, fill = "dodgerblue2", size = .1) +  
    # P/V/C
    annotate("rect", xmin = P.V.C$Start, xmax = P.V.C$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "yellow3", col = "black", size = .1) +
    annotate(geom = "text", x = (P.V.C$Stop + P.V.C$Start)/2, y = .05, label = "P/V/C", size = 8) +
    annotate("rect", xmin = P.V.C$Start, xmax = P.V.C$Stop, ymin = 0, ymax = 2.5 ,
               alpha = .1, fill = "yellow3", size = .1) +
    # Matrix protein
    annotate("rect", xmin = M$Start, xmax = M$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "#FF7F00", col = "black", size = .1) +
    annotate(geom = "text", x = (M$Stop + M$Start)/2, y = .05, label = "M", size = 8)  +
    annotate("rect", xmin = M$Start, xmax = M$Stop, ymin = 0, ymax = 2.5 ,
               alpha = .1, fill = "#FF7F00", size = .1) +
    # Fusion protein
    annotate("rect", xmin = F.$Start, xmax = F.$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "#6A3D9A", col = "black", size = .1) +
    annotate(geom = "text", x = (F.$Stop + F.$Start)/2, y = .05, label = "F", size = 8) +
    annotate("rect", xmin = F.$Start, xmax = F.$Stop, ymin = 0, ymax = 2.5 ,
               alpha = .1, fill = "#6A3D9A", size = .1) +
    # Hemagluttinin
    annotate("rect", xmin = H$Start, xmax = H$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "green4", col = "black", size = .1) +
    annotate(geom = "text", x = (H$Stop + H$Start)/2, y = .05, label = "H", size = 8) +
    annotate("rect", xmin = H$Start, xmax = H$Stop, ymin = 0, ymax = 2.5,
               alpha = .1, fill = "green4", size = .1) +
    # Large protein
    annotate("rect", xmin = L$Start, xmax = L$Stop, ymin = 0, ymax = .1 ,
               alpha = .2, fill = "#E31A1C", col = "black", size = .1) +
    annotate(geom = "text", x = (L$Stop + L$Start)/2, y = .05, label = "L", size = 8) +
    annotate("rect", xmin = L$Start, xmax = L$Stop, ymin = 0, ymax = 2.5 ,
               alpha = .1, fill = "#E31A1C", size = .1) +
    theme_classic() +
    theme(panel.grid.major.y = element_line(colour="grey", linetype="dashed")) +
    theme(legend.position="bottom", legend.box = "horizontal") +
    theme(legend.box.background = element_rect(colour = "black")) +
    theme(text=element_text(size=24)) + 
    theme(axis.text.x = element_text(size=28)) + 
    theme(axis.title.x = element_text(size=30)) + 
    theme(plot.title = element_text(hjust = 0.5))  +
    theme(axis.title.y = element_blank()) +
    scale_x_continuous(limits=c(0,16000)) +
    theme(legend.position = "none") 

# ggsave("../../results/figures/subclonal-snps-in-g1-and-g2.png", width = 10, height = 8, dpi = 300)

```

## Expected Frequency Approach

This approach relies on the expected frequencies of haplotypes given that they've arisen on the background of either`Genome 1` or `Genome 2`. We'll compute the log likelihood of observing the counts a SNP on a given background (SNP - G1, SNP - G2, WT - G1, WT - G2) given the expected frequencies under the assumption that the SNP is on the background of one genotype or the other. We'll sum the log likelihood over every tissue sample.

```{r Compute Log Likelihood, echo = T}

# TODO: Remove the f_g2 argument, it's not necessary

loglik.g1.g2 = function(x11, x10, x01, x00, f_g1, f_g2, f_c, error) {
  
  # Compute the expected frequencies of each possible haplotype given the SNP is on Genome 1
  f11 = (f_c + error) / (1 + 4*error)
  f10 = max(0 + error, (f_g1 - f_c + error)) / (1 + 4*error)
  f01 = (0 + error) / (1 + 4*error)
  f00 = 1 - f11 - f10 - f01 

  # What is the probability of observing x11, x10, x01, x00 under these expected frequencies?
  lik.g1 = -(dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T))

  # Compute the expected frequencies of each possible haplotype given the SNP is on Genome 1
  f11 = (0 + error)/(1 + 4*error)
  f01 = (f_c + error)/(1 + 4*error)
  f00 = max(0 + error, 1 - f_g1 - f01 + error)/(1 + 4*error)
  f10 = 1 - f11 - f00 - f01 
  
  # What is the probability of observing x11, x10, x01, x00 under these expected frequencies?
  lik.g2 = -(dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T))
  
  return(c(lik.g1, lik.g2))
}

```

I called the overlapping reads by position rather than SNP. This means that it's possible for there to be reads that overlap SNPs in more than one haplotype. There is only one position where this is the case. I'll mask this position below. 

```{r Format Bridging Reads, echo = T}

# Cutoff for minimum bridging depth
min.bridging.depth = 10
  
# Labels for the haplotypes
haplotype.labels = updated.df %>% 
  select(POS, Haplotype) %>% 
  distinct()

# Duplicate Positions 
# TODO: Update the bridging read script to allele rather than position
masked.shared.positions = haplotype.labels %>% 
  group_by(POS) %>% 
  count() %>% 
  filter(n > 1) %>% 
  pull(POS)

# Filter the bridging read pairs 
labled.bridging.df = bridging.df %>% 
  # Add the snp_1 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_1 = POS, hap_1 = Haplotype)) %>% 
  # Add the snp_2 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_2 = POS, hap_2 = Haplotype)) %>% 
  # Remove all subclonal SNPs
  filter(hap_1 != "subclonal" & hap_2 != "subclonal") %>% 
  # We're only comparing to the two major genotypes
  filter(hap_1 %in% c("genome-1", "genome-2") | hap_2 %in% c("genome-1", "genome-2")) %>% 
  # We don't want cases with only genome 1 or genome 2
  filter(!(hap_1 %in% c("genome-1", "genome-2") & hap_2 %in% c("genome-1", "genome-2"))) %>% 
  # Mask the shared position 
  filter(!snp_1 %in% masked.shared.positions, !snp_2 %in% masked.shared.positions) %>% 
  # Filter based one some minimum bridging depth cutoff
  filter((`00` + `01` + `10` + `11`) > min.bridging.depth)

# Get all pairs to test 
pairs.to.test = labled.bridging.df %>% 
  select(snp_1, snp_2) %>% 
  distinct()

```

```{r Test All SNP Pairs, echo = T}

# Check the background for all SNPs with reads bridging to Genome 1 or Genome 2
background.test.df = foreach(i = 1:nrow(pairs.to.test), .combine = "rbind") %do% {

    # Print out the progress 
    if(i %% 100 == 0){
      print(paste("Testing pair", i, "out of", nrow(pairs.to.test), "total pairs..."))
    }

    # Get the SNPs being tested 
    snp.1 = (pairs.to.test %>% slice(n = i))$snp_1
    snp.2 = (pairs.to.test %>% slice(n = i))$snp_2

    # Get some info on the SNPs being compared
    snp.1.info = expanded.df %>%
      filter(POS == snp.1) %>% 
      select(SNP, POS, Tissue, Haplotype)
    snp.2.info = expanded.df %>%
      filter(POS == snp.2)  %>% 
      select(SNP, POS, Tissue, Haplotype)
    
    # Get the haplotypes for the SNPs being compared
    snp.1.haplotype = unique(snp.1.info$Haplotype)[1]
    snp.2.haplotype = unique(snp.2.info$Haplotype)[1]

    # Get the haplotype of the cluster SNP
    haplotype = setdiff(c(snp.1.haplotype, snp.2.haplotype), c("genome-1", "genome-2"))
    
    # Get the read overlaps for these two SNPs
    overlaps = labled.bridging.df %>% filter(snp_1 == snp.1 & snp_2 == snp.2)

    # Test the linkage to genome 1 & 2 for each tissue sample
    tissue.test = foreach(tissue = unique(haplotype.mean$Tissue), .combine = "rbind") %do% {
      
      # Get the frequency of genome 1 and genome 2 in this tissue
      g1.freq = haplotype.mean %>%
        filter(Haplotype == "genome-1", Tissue == tissue) %>% 
        pull(AF)
      g2.freq = haplotype.mean %>%
        filter(Haplotype == "genome-2", Tissue == tissue) %>% 
        pull(AF)

      # Normalize the frequencies of genome 1 and genome 2
      total.freq = g1.freq + g2.freq
      g1.freq = g1.freq / total.freq
      g2.freq = g2.freq / total.freq
      
      # Get the haplotype ("cluster") frequency for the comparison 
      cluster.freq = max(0, filter(haplotype.mean, Haplotype == haplotype, Tissue == tissue)$AF)

      # Get the bridging reads for this tissue comparison
      comparison.read.counts = overlaps %>%
        filter(Tissue == tissue)

      # x11 refers to the number of reads overlapping the cluster SNP and the G1 SNP
      x11 = NA
      # x10 is the number of reads overlapping G1 SNP and NOT the cluster SNP
      x10 = NA
      # x01 is the number of reads overlapping the cluster SNP and NOT the G1 SNP
      x01 = NA
      # x00 is the number of reads NOT overlapping the cluster SNP and NOT overlapping the G1 SNP
      x00 = NA

      # There are a total of four possible configurations of the data: 
      if(!snp.1.haplotype %in% c("genome-1", "genome-2") & snp.2.haplotype %in% c("genome-1", "genome-2")){
        # 1. snp_1 is the cluster SNP, and snp_2 is G1 linked
        if (snp.2.haplotype == "genome-1") {
            x11 = comparison.read.counts$`11`
            x10 = comparison.read.counts$`01`
            x01 = comparison.read.counts$`10`
            x00 = comparison.read.counts$`00`
          }
        # 2. snp_1 is the cluster SNP, and snp_2 is G2 linked         
        if (snp.2.haplotype == "genome-2") {
              x11 = comparison.read.counts$`10`
              x10 = comparison.read.counts$`00`
              x01 = comparison.read.counts$`11`
              x00 = comparison.read.counts$`01`
        }
      }
      if(!snp.2.haplotype %in% c("genome-1", "genome-2") & snp.1.haplotype %in% c("genome-1", "genome-2")) {
        # 3. snp_1 is NOT the cluster SNP, and snp_1 is G1 linked
        if (snp.1.haplotype == "genome-1") {
          x11 = comparison.read.counts$`11`
          x10 = comparison.read.counts$`10`
          x01 = comparison.read.counts$`01`
          x00 = comparison.read.counts$`00`
        }
        # 4. snp_1 is NOT the cluster SNP, and snp_1 is G2 linked
        if (snp.1.haplotype == "genome-2") {
          x11 = comparison.read.counts$`01`
          x10 = comparison.read.counts$`00`
          x01 = comparison.read.counts$`11`
          x00 = comparison.read.counts$`10`
        }
      }

      # Compute the log likelihood for the counts determined above
      if (nrow(comparison.read.counts) == 0) {
        results = c(NA, NA)
      } else {
        results = loglik.g1.g2(x11, x10, x01, x00, g1.freq, g2.freq, cluster.freq/total.freq, error = 0.01)
      }
      # Return the results
      return(results)
    }
    
    # Sum the log likelihoods across all tissues 
    AICs = 2 * apply(tissue.test, 2, sum, na.rm = TRUE)
    # Calculate relative likelihood 
    AIC.min = min(AICs)
    rel.g1 = exp((AIC.min - AICs[1])/2)
    rel.g2 = exp((AIC.min - AICs[2])/2)
    lik.g1 = rel.g1 / (rel.g1 + rel.g2)
    lik.g2 = rel.g2 / (rel.g1 + rel.g2)
    # Determine the background
    background = c("genome-1", "genome-2", "neither")[
      c(lik.g1 > 0.95, lik.g2 > 0.95, 
        lik.g1 < 0.95 & lik.g2 < 0.95)
      ]
    # Write to a row
    tibble(snp_1 = snp.1, snp_2 = snp.2, background, haplotype, lik.g1, lik.g2)

}

```
How well do pairs of SNPs agree for each cluster/haplotype?

```{r Expected Frequency Assignment, fig.align='center', fig.width=16, fig.height=8}

cols = c("grey", "#bf1515", "#0251d9")
names(cols) = c("neither", "genome-2", "genome-1")

snp_positions = expanded.df %>%
  group_by(Haplotype, POS) %>% 
  count() %>%
  rename(haplotype = Haplotype) %>% 
  filter(!is.element(haplotype, c("both", "subclonal", "genome-1", "genome-2")))

background.test.df %>% 
  filter(haplotype != "both") %>%
  group_by(haplotype) %>%
  mutate(ind = 1:n() )%>% 
  ggplot() +
    geom_segment(aes(x = snp_1, xend = snp_2, y = ind, yend = ind, col = background), size = 3) + 
    geom_vline(data = snp_positions, aes(xintercept = POS), col = "black", size = 0.1) +
    facet_wrap(~haplotype, scales = "free_y") + labs(x = "Position", y = "SNP pair") + 
    scale_color_manual(values = cols) + theme(legend.position = "none") + 
    theme_classic(18) 

```

Group by the background assignments for each cluster and count (`G1`, `G2`, and `Neither`). Assign a definitive background based on the max of the two. Pull out the SNPs that disagree for each cluster condition.

```{r Summarize Background Assignment, echo=T}

background.assignment = background.test.df %>% 
  filter(haplotype != "both") %>% 
  group_by(haplotype, background) %>% 
  count() %>% 
  pivot_wider(names_from = background, values_from = n, values_fill = 0) %>% 
  select(!neither) %>% 
  mutate(Background = case_when(
    `genome-1` > `genome-2` ~ 'genome-1',
    `genome-1` < `genome-2` ~ 'genome-2'
  )) %>% 
  mutate(Disagreement = if_else((`genome-1` > 0 & `genome-2` > 0), T, F))

```

There are `r nrow(filter(background.assignment, Disagreement))` clusters with SNPs that were assigned to both `genome-1` and `genome-2`. Let's look at these more closely.

```{r Disagreeing Clusters, echo=F}

disagreeing.clusters = background.assignment %>% 
  filter(Disagreement)

disagreeing.clusters

```

Both of these clusters were assigned to `genome-2`. Let's pull out the SNPs from these clusters that mapped to `genome-1` and see where these SNPs are from. 

```{r Disagreeing SNPs, echo=T}

disagreeing.snps = background.test.df %>% 
  filter(haplotype %in% disagreeing.clusters$haplotype,
         background == 'genome-1') %>% 
  pull(snp_2) %>% 
  unique()

disagreeing.snps

```

There are only `r length(disagreeing.snps)` that disagree from the main cluster assignment, both in the Matrix protein where we expected the highest amount of homoplasy. It's possible that these SNPs are present on *both* `genome-1` and `genome-2`. 

## Annotate the Haplotypes 

We're going to use the 'expected frequency` method to assign genotypes to the phased clusters. This method is most explainable, although both methods ultimately give the same results. 

```{r Write out the assignments, echo=TRUE}

# Add rows for the non-cluster haplotype options
background.assignment = background.assignment %>% 
  ungroup() %>% 
  select(Haplotype = haplotype, Background) %>% 
  add_row(Haplotype = "genome-1", Background = "genome-1") %>% 
  add_row(Haplotype = "genome-2", Background = "genome-2") %>% 
  add_row(Haplotype = "both", Background = "both") %>% 
  add_row(Haplotype = "subclonal", Background = "subclonal") 

# Drop the old background assignments and add the new ones
assigned.df = updated.df %>% 
  select(!Background) %>% 
  left_join(., background.assignment, by = "Haplotype")
  
# Write out to assigned file. 
write_csv(assigned.df, output.path)

```



