---
title: "4. Assign Haplotype Backgrounds"
author:
    - "Will Hannon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
---

The goal of this notebook is to establish a method to genotype SNPs as either belonging to `Genome 1` or to `Genome 2`. We'll test two different approaches that make use of reads that 'bridge' between haplotype/cluster SNPs and SNPs in `Genome-1` and `Genome-2`.  **The output of this notebook is a set of phased variants with `Genome 1` and `Genome 2` assignments renamed so that haplotypes are in sequential order.**

```{r Setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = FALSE)
```

```{r Required Packages, message=FALSE, warning=FALSE, echo=FALSE}

## ==== Install Required Packages ==== ##

## List of all packages needed
packages = c("tidyverse", "foreach", "emdbook")

## Packages loading
invisible(lapply(c(packages), library, character.only = TRUE))

```

```{r Inputs, echo=T}

## ==== File paths input data ==== ##

if (exists("snakemake")) {
  
  # Phased variants with haplotype annotations
  updated.data = snakemake@params[["incsv"]]
  
  # Annotations for MeV genes
  annotations.filepath = snakemake@params[["annotations"]]
  
  # Counts of SNPs on reads belonging to genome-1 or genome-2
  g1.g2.reads.data = snakemake@input[[1]]
  
  # Counts of all reads bridging *all* pairs of SNP positions
  bridging.reads.data = snakemake@input[[2]]

} else {
  
  # Phased variants with haplotype annotations
  updated.data = "../../results/variants/clustered_variants.csv"
  
  # Annotations for MeV genes
  annotations.filepath = "../../config/annotations.csv"
  
  # Counts of SNPs on reads belonging to genome-1 or genome-2
  g1.g2.reads.data = "../../results/bridging/genotyped.csv"
  
  # Counts of all reads bridging *all* pairs of SNP positions
  bridging.reads.data = "../../results/bridging/bridging_reads.csv"
  
}

```

```{r Outputs, echo=T}

## ==== File paths output data ==== ##

# Path to save the results
if (exists("snakemake")) {
  
  # G1 and G2 assigned variants
  output.path = snakemake@params[['outcsv']]

  # Path to save figures
  figure.dir = snakemake@params[['figures']]
  
} else {
  
  # G1 and G2 assigned variants
  output.path = "../../results/variants/assigned_variants.csv"

  # Path to save figures
  figure.dir = "../../results/figures/"
  
}

# Make the figure directory if it doesn't exist
if (!file.exists(figure.dir)) {
  dir.create(figure.dir, recursive = TRUE)
  print("Directory created.")
} else {
  print("Directory already exists.")
}

```

```{r Import and Format Data, message=F, echo=F}

# Import the SNPs that were phased in the previous notebook 
updated.df = read_csv(updated.data, show_col_types = FALSE)

# Get the haplotype names for each SNP
haplotypes.label = updated.df %>% 
  select(Haplotype, SNP) %>% 
  distinct()

# Expand the haplotyped SNPs to have records for all tissues
expanded.df = updated.df %>% 
  select(SNP, Tissue, AF) %>% 
  pivot_wider(names_from = "Tissue", values_from = "AF", values_fill = 0) %>% 
  pivot_longer(cols = !SNP, names_to = "Tissue", values_to = "AF") %>% 
  left_join(., select(updated.df, c("SNP", "Tissue", "DP",)), by = c("SNP", "Tissue")) %>% 
  mutate(DP = if_else(is.na(DP), 0, DP)) %>% 
  left_join(., distinct(select(updated.df, c("SNP", "POS"))), by = c("SNP")) %>% 
  left_join(., haplotypes.label, by = "SNP") 

# Calculate the mean haplotype frequency across each tissue
haplotype.mean = expanded.df %>% 
  group_by(Tissue, Haplotype) %>% 
  summarize(AF = mean(AF))

# Import the counts of SNPs on genome-1 and genome-2 backgrounds for the CliqueSNV approach 
genotyping.df = read_csv(g1.g2.reads.data, show_col_types = FALSE) %>% 
  select(!AF) %>% 
  rename(total = DP, 
         var = OBSV) %>% 
  mutate(genotype = if_else(genotype == "genome-1", "g1", "g2")) %>% 
  pivot_wider(names_from = genotype,
              values_from = c(total, var), 
              names_sep = "_", 
              values_fill = 0) %>% 
  left_join(., haplotypes.label, by = "SNP") 

# Import the reads that bridge all pairs of SNPs for the multinomial approach
bridging.df = read_csv(bridging.reads.data, show_col_types = FALSE)

```

## CliqueSNV Approach 

This approach is derived from a part of the [`CliqueSNV`](https://academic.oup.com/nar/article/49/17/e102/6313236) algorithm. It's used to determine if SNPs are linked or forbidden from counts of reads overlapping both SNPs. This is one of two approaches that we'll use to assign the haplotypes to `Genome 1` or `Genome 2`. 

```{r Assign Genotypes for each Tau, echo=T}

# Log-spaced sequence of taus
taus = lseq(0.00001, 1, length.out = 200)

# Minimum significance
min.sig = 0.05

# Minimum number of variant observations? 

# Assign to genome for each value of tau
assignmentsByTau = foreach(tau = taus, .combine = "rbind")%do%{

    allSNPs = genotyping.df %>% 
        gather(cat, count, -POS, -REF, -ALT, -SNP, -Tissue, -Haplotype) %>% 
        separate(cat, into = c("cat", "G"), sep = "_") %>% 
        spread(cat, count) %>% 
        group_by(SNP, G) %>% 
        mutate(linked= pbinom( var, total, tau, lower.tail = FALSE), 
               sig = linked < min.sig/n()) %>% 
        mutate(sig = ifelse(total == 0, NA, sig)) %>% 
        summarize(TissueCount = sum(sig, na.rm = TRUE), .groups = "drop") %>% 
        spread(G, TissueCount) %>% 
        mutate(G1orG2 = ifelse(g1 > 0 & g2 == 0, "G1",
                        ifelse(g2 > 0 & g1 == 0, "G2", 
                        ifelse(g1 > 0 & g2 > 0, "G1/G2", 
                        ifelse(g1 == 0 & g2 == 0, "-", "*"))))) %>% 
        ungroup()


    left_join(genotyping.df, allSNPs, by = "SNP") %>% select( -total_g1, -total_g2, -var_g1, -var_g2) %>% mutate(tau = tau)

}

```

What are the `Genome 1` and `Genome 2` assignments for each haplotype/cluster for every value of `tau` between `0.00001` and `1`? 

```{r Assignments for all Haplotypes, warning=F, message=F, echo=F, fig.align='center', fig.width=18, fig.height=14}

assignment.order = c('G1', 'G2', 'G1/G2', '-')
assignment.colors = c("#307EC2", "#B63F3E", "purple", "darkgrey")
  
assignmentsByTau %>%
  select(-Tissue) %>% 
  unique() %>%
  group_by(G1orG2, Haplotype, tau) %>%
  summarize(n = n()) %>% 
  spread(G1orG2, n) %>%
  gather(type, count, -Haplotype, -tau) %>% 
  mutate(count = ifelse(is.na(count), 0, count)) %>%
  spread(type, count) %>% 
  gather(type, count, -Haplotype, -tau) %>%
  group_by(Haplotype, tau) %>%
  mutate(total = sum(count)) %>% 
  mutate(prop = count/total) %>% 
    ggplot(aes(x = tau, y = prop, col = factor(type, level = assignment.order), group = type)) +
      geom_path(size = 1.5) + 
      scale_x_log10() +
      facet_wrap(~Haplotype) +
      labs(y = "Proportion of SNPs assigned") +  
      scale_color_manual(values = assignment.colors, name = "Genome Assignment") +
      theme_classic() +
      theme(panel.grid.major.y = element_line(colour="grey", linetype="dashed")) +
      theme(legend.position="bottom", legend.box = "horizontal") +
      theme(legend.box.background = element_rect(colour = "black")) +
      theme(text=element_text(size=18)) + 
      theme(plot.title = element_text(hjust = 0.5)) 


```

## Expected Frequency Approach

This approach relies on the expected frequencies of haplotypes given that they've arisen on the background of either `Genome 1` or `Genome 2`. We'll compute the log likelihood of observing the counts a SNP on a given background (SNP - G1, SNP - G2, WT - G1, WT - G2) given the expected frequencies under the assumption that the SNP is on the background of one genotype or the other. We'll sum the log likelihood over every tissue sample.

```{r Compute Log Likelihood, echo = T}

loglik.g1.g2 = function(x11, x10, x01, x00, f_g1, f_g2, f_c, error) {
  
  # Compute the expected frequencies of each possible haplotype given the SNP is on Genome 1
  f11 = (f_c + error) / (1 + 4*error)
  f10 = max(0 + error, (f_g1 - f_c + error)) / (1 + 4*error)
  f01 = (0 + error) / (1 + 4*error)
  f00 = 1 - f11 - f10 - f01 

  # What is the probability of observing x11, x10, x01, x00 under these expected frequencies?
  lik.g1 = -(dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T))

  # Compute the expected frequencies of each possible haplotype given the SNP is on Genome 1
  f11 = (0 + error)/(1 + 4*error)
  f01 = (f_c + error)/(1 + 4*error)
  f00 = max(0 + error, 1 - f_g1 - f01 + error)/(1 + 4*error)
  f10 = 1 - f11 - f00 - f01 
  
  # What is the probability of observing x11, x10, x01, x00 under these expected frequencies?
  lik.g2 = -(dmultinom(c(x11, x10, x01, x00), prob = c(f11, f10, f01, f00), log = T))
  
  return(c(lik.g1, lik.g2))
  
}

```

I called the overlapping reads by position rather than SNP. This means that it's possible for there to be reads that overlap SNPs in more than one haplotype. There is only one position where this is the case. I'll mask this position below. 

```{r Format Bridging Reads, message=F, echo=T}

# Cutoff for minimum bridging depth
min.bridging.depth = 10
  
# Labels for the haplotypes
haplotype.labels = updated.df %>% 
  select(POS, Haplotype) %>% 
  distinct()

# Maks Duplicate Positions 
masked.shared.positions = haplotype.labels %>% 
  group_by(POS) %>% 
  count() %>% 
  filter(n > 1) %>% 
  pull(POS)

# Filter the bridging read pairs 
labled.bridging.df = bridging.df %>% 
  # Add the snp_1 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_1 = POS, hap_1 = Haplotype)) %>% 
  # Add the snp_2 haplotype label
  left_join(., dplyr::rename(haplotype.labels, snp_2 = POS, hap_2 = Haplotype)) %>% 
  # Remove all subclonal SNPs
  filter(hap_1 != "subclonal" & hap_2 != "subclonal") %>% 
  # We're only comparing to the two major genotypes
  filter(hap_1 %in% c("genome-1", "genome-2") | hap_2 %in% c("genome-1", "genome-2")) %>% 
  # We don't want cases with only genome 1 or genome 2
  filter(!(hap_1 %in% c("genome-1", "genome-2") & hap_2 %in% c("genome-1", "genome-2"))) %>% 
  # Mask the shared position 
  filter(!snp_1 %in% masked.shared.positions, !snp_2 %in% masked.shared.positions) %>% 
  # Filter based one some minimum bridging depth cutoff
  filter((`00` + `01` + `10` + `11`) > min.bridging.depth)

# Get all pairs to test 
pairs.to.test = labled.bridging.df %>% 
  select(snp_1, snp_2) %>% 
  distinct()

```

Below, I'll test all of the pairs of SNPs where one SNP belongs to a phased cluster/haplotype and the other SNP belongs to either `Genome 1` or `Genome 2`.

```{r Test All SNP Pairs, echo=T}

# Check the background for all SNPs with reads bridging to Genome 1 or Genome 2
background.test.df = foreach(i = 1:nrow(pairs.to.test), .combine = "rbind") %do% {

    # Print out the progress 
    if(i %% 100 == 0){
      print(paste("Testing pair", i, "out of", nrow(pairs.to.test), "total pairs..."))
    }

    # Get the SNPs being tested 
    snp.1 = (pairs.to.test %>% slice(n = i))$snp_1
    snp.2 = (pairs.to.test %>% slice(n = i))$snp_2

    # Get some info on the SNPs being compared
    snp.1.info = expanded.df %>%
      filter(POS == snp.1) %>% 
      select(SNP, POS, Tissue, Haplotype)
    snp.2.info = expanded.df %>%
      filter(POS == snp.2)  %>% 
      select(SNP, POS, Tissue, Haplotype)
    
    # Get the haplotypes for the SNPs being compared
    snp.1.haplotype = unique(snp.1.info$Haplotype)[1]
    snp.2.haplotype = unique(snp.2.info$Haplotype)[1]

    # Get the haplotype of the cluster SNP
    haplotype = setdiff(c(snp.1.haplotype, snp.2.haplotype), c("genome-1", "genome-2"))
    
    # Get the read overlaps for these two SNPs
    overlaps = labled.bridging.df %>% filter(snp_1 == snp.1 & snp_2 == snp.2)

    # Test the linkage to genome 1 & 2 for each tissue sample
    tissue.test = foreach(tissue = unique(haplotype.mean$Tissue), .combine = "rbind") %do% {
      
      # Get the frequency of genome 1 and genome 2 in this tissue
      g1.freq = haplotype.mean %>%
        filter(Haplotype == "genome-1", Tissue == tissue) %>% 
        pull(AF)
      g2.freq = haplotype.mean %>%
        filter(Haplotype == "genome-2", Tissue == tissue) %>% 
        pull(AF)

      # Normalize the frequencies of genome 1 and genome 2
      total.freq = g1.freq + g2.freq
      g1.freq = g1.freq / total.freq
      g2.freq = g2.freq / total.freq
      
      # Get the haplotype ("cluster") frequency for the comparison 
      cluster.freq = max(0, filter(haplotype.mean, Haplotype == haplotype, Tissue == tissue)$AF)

      # Get the bridging reads for this tissue comparison
      comparison.read.counts = overlaps %>%
        filter(Tissue == tissue)

      # x11 refers to the number of reads overlapping the cluster SNP and the G1 SNP
      x11 = NA
      # x10 is the number of reads overlapping G1 SNP and NOT the cluster SNP
      x10 = NA
      # x01 is the number of reads overlapping the cluster SNP and NOT the G1 SNP
      x01 = NA
      # x00 is the number of reads NOT overlapping the cluster SNP and NOT overlapping the G1 SNP
      x00 = NA

      # There are a total of four possible configurations of the data: 
      if(!snp.1.haplotype %in% c("genome-1", "genome-2") & snp.2.haplotype %in% c("genome-1", "genome-2")){
        # 1. snp_1 is the cluster SNP, and snp_2 is G1 linked
        if (snp.2.haplotype == "genome-1") {
            x11 = comparison.read.counts$`11`
            x10 = comparison.read.counts$`01`
            x01 = comparison.read.counts$`10`
            x00 = comparison.read.counts$`00`
          }
        # 2. snp_1 is the cluster SNP, and snp_2 is G2 linked         
        if (snp.2.haplotype == "genome-2") {
              x11 = comparison.read.counts$`10`
              x10 = comparison.read.counts$`00`
              x01 = comparison.read.counts$`11`
              x00 = comparison.read.counts$`01`
        }
      }
      if(!snp.2.haplotype %in% c("genome-1", "genome-2") & snp.1.haplotype %in% c("genome-1", "genome-2")) {
        # 3. snp_1 is NOT the cluster SNP, and snp_1 is G1 linked
        if (snp.1.haplotype == "genome-1") {
          x11 = comparison.read.counts$`11`
          x10 = comparison.read.counts$`10`
          x01 = comparison.read.counts$`01`
          x00 = comparison.read.counts$`00`
        }
        # 4. snp_1 is NOT the cluster SNP, and snp_1 is G2 linked
        if (snp.1.haplotype == "genome-2") {
          x11 = comparison.read.counts$`01`
          x10 = comparison.read.counts$`00`
          x01 = comparison.read.counts$`11`
          x00 = comparison.read.counts$`10`
        }
      }

      # Compute the log likelihood for the counts determined above
      if (nrow(comparison.read.counts) == 0) {
        results = c(NA, NA)
      } else {
        results = loglik.g1.g2(x11, x10, x01, x00, g1.freq, g2.freq, cluster.freq/total.freq, error = 0.01)
      }
      # Return the results
      return(results)
    }
    
    # Sum the log likelihoods across all tissues 
    AICs = 2 * apply(tissue.test, 2, sum, na.rm = TRUE)
    # Calculate relative likelihood 
    AIC.min = min(AICs)
    rel.g1 = exp((AIC.min - AICs[1])/2)
    rel.g2 = exp((AIC.min - AICs[2])/2)
    lik.g1 = rel.g1 / (rel.g1 + rel.g2)
    lik.g2 = rel.g2 / (rel.g1 + rel.g2)
    # Determine the background
    background = c("genome-1", "genome-2", "neither")[
      c(lik.g1 > 0.95, lik.g2 > 0.95, 
        lik.g1 < 0.95 & lik.g2 < 0.95)
      ]
    # Write to a row
    tibble(snp_1 = snp.1, snp_2 = snp.2, background, haplotype, lik.g1, lik.g2)

}

```

Now, let's see how the pairs of SNPs agree for each cluster/haplotype.

```{r Expected Frequency Assignment, echo=F, fig.align='center', fig.width=16, fig.height=8}

cols = c("grey", "#bf1515", "#0251d9")
names(cols) = c("neither", "genome-2", "genome-1")

snp_positions = expanded.df %>%
  group_by(Haplotype, POS) %>% 
  count() %>%
  rename(haplotype = Haplotype) %>% 
  filter(!is.element(haplotype, c("both", "subclonal", "genome-1", "genome-2")))

background.test.df %>% 
  filter(haplotype != "both") %>%
  group_by(haplotype) %>%
  mutate(ind = 1:n() )%>% 
  ggplot() +
    geom_segment(aes(x = snp_1, xend = snp_2, y = ind, yend = ind, col = background), size = 3) + 
    geom_vline(data = snp_positions, aes(xintercept = POS), col = "black", size = 0.1) +
    facet_wrap(~haplotype, scales = "free_y") + labs(x = "Position", y = "SNP pair") + 
    scale_color_manual(values = cols) + theme(legend.position = "none") + 
    theme_classic(18) 

```

Group by the background assignments for each cluster and count (`Genome 1`, `Genome 2`, and `Neither`). Assign a definitive background based on the max of the two. Pull out the SNPs that disagree for each cluster condition.

```{r Summarize Background Assignment, echo=T}

background.assignment = background.test.df %>% 
  filter(haplotype != "both") %>% 
  group_by(haplotype, background) %>% 
  count() %>% 
  pivot_wider(names_from = background, values_from = n, values_fill = 0) %>% 
  select(!neither) %>% 
  mutate(Background = case_when(
    `genome-1` > `genome-2` ~ 'genome-1',
    `genome-1` < `genome-2` ~ 'genome-2'
  )) %>% 
  mutate(Disagreement = if_else((`genome-1` > 0 & `genome-2` > 0), T, F))

```

There is `r nrow(filter(background.assignment, Disagreement))` cluster with SNPs that were assigned to both `Genome 1` and `Genome 2`. 

```{r Disagreeing Clusters, echo=F}

disagreeing.clusters = background.assignment %>% 
  filter(Disagreement)

disagreeing.clusters %>% 
  kable(., caption = "Disagreeing Clusters")

```

Let's pull out the SNPs that map to the opposite background as the cluster assignment and see where these SNPs are located in the genome. 

```{r Disagreeing SNPs, echo=F}

disagreeing.snps = background.test.df %>% 
  filter(haplotype %in% disagreeing.clusters$haplotype,
         background == 'genome-1') %>% 
  pull(snp_2) %>% 
  unique()

print(disagreeing.snps)

```

There is only `r length(disagreeing.snps)` SNP that disagrees from the main cluster assignment. Unsurprisingly, this SNP is in the Matrix protein where we expected the highest amount of homoplasy. It's reasonable that this SNP is present on *both* `Genome 1` and `Genome 2`. 

## Annotate the Haplotypes 

We're going to use the 'expected frequency' method to assign genotypes to the phased clusters. This method is most explainable, although both methods ultimately give the same results. I'll add these background assignments to the variants.

```{r Add the assignments, echo=T}

# Add rows for the non-cluster haplotype options
background.assignment = background.assignment %>% 
  ungroup() %>% 
  select(Haplotype = haplotype, Background) %>% 
  add_row(Haplotype = "genome-1", Background = "genome-1") %>% 
  add_row(Haplotype = "genome-2", Background = "genome-2") %>% 
  add_row(Haplotype = "both", Background = "both") %>% 
  add_row(Haplotype = "subclonal", Background = "subclonal") 

# Drop the old background assignments and add the new ones
assigned.df = updated.df %>% 
  select(!Background) %>% 
  left_join(., background.assignment, by = "Haplotype")
  
```

Then, to attempt to give some reason to the cluster numbers, I'll rename them in sequential order starting with the haplotypes assigned to `Genome 1` then moving on the `Genome 2`. Within each background the clusters are ordered based on mean frequency.

```{r Rename in Sequential Order, echo=T}

# Get the new 'sequential' haplotype names
haplotype.names = assigned.df %>%
  filter(str_detect(Haplotype, "^cluster")) %>% 
  select(SNP, AF, Haplotype, Background) %>% 
  group_by(Haplotype, Background) %>% 
  summarise(AF = mean(AF)) %>% 
  group_by(Background) %>% 
  arrange(-AF, .by_group=T) %>% 
  ungroup() %>% 
  mutate(New_Haplotype = paste("cluster", row_number())) %>% 
  select(Haplotype, New_Haplotype)


assigned.df = assigned.df %>% 
  left_join(., haplotype.names, by = "Haplotype") %>% 
  mutate(New_Haplotype = if_else(is.na(New_Haplotype), Haplotype, New_Haplotype)) %>% 
  rename(Cluster = Haplotype, Haplotype = New_Haplotype)
  
```

What do these validated clusters look like? 

```{r Renamed Haplotypes, message=F, warning=F, fig.align='center', fig.width=19, fig.height=10, echo=F}

# Get the haplotype names
haplotypes.label = assigned.df %>% 
  select(SNP, Haplotype, Background) %>% 
  distinct()

# Expand the mutations to have a frequency for every tissue.
expanded.df = assigned.df %>% 
  select(SNP, Tissue, AF) %>% 
  pivot_wider(names_from = "Tissue", values_from = "AF", values_fill = 0) %>% 
  pivot_longer(cols = !SNP, names_to = "Tissue", values_to = "AF") %>% 
  left_join(., select(assigned.df, c("SNP", "Tissue", "DP")), by = c("SNP", "Tissue")) %>% 
  mutate(DP = if_else(is.na(DP), 0, DP)) %>% 
  left_join(., haplotypes.label, by = "SNP") 

# Tissue order - roughly by the location in the brain 
tissue.order = c(
  "SSPE 1", 
  "SSPE 2",
  "Frontal Cortex 2", 
  "Frontal Cortex 1", 
  "Frontal Cortex 3", 
  "Parietal Lobe",
  "Temporal Lobe", 
  "Occipital Lobe",
  "Hippocampus",
  "Internal Capsule", 
  "Midbrain", 
  "Upper Brain Stem",
  "Brain Stem",
  "Cerebellum",
  "Cerebellum Nucleus"
)

haplotype.order = c("cluster 1",
                    "cluster 2",
                    "cluster 3",
                    "cluster 4",
                    "cluster 5",
                    "cluster 6",
                    "cluster 7",
                    "cluster 8",
                    "cluster 9",
                    "cluster 10",
                    "cluster 11",
                    "cluster 12",
                    "cluster 13")

expanded.df %>% 
    filter(Haplotype %in% haplotype.order) %>% 
    mutate(Tissue = case_when(
      Tissue == "UBS" ~ "Upper Brain Stem",
      TRUE ~ Tissue
    )) %>% 
    mutate(Genotype = case_when(
      Background == "genome-1" ~ "G1",
      Background == "genome-2" ~ "G2"
    )) %>% 
    ggplot(aes(x = factor(Tissue, levels = tissue.order), y = AF, col = (Genotype))) +
      geom_line(aes(group = SNP)) +
      facet_wrap(~factor(Haplotype, levels = haplotype.order)) + 
      scale_color_manual(values=c("#424ef5", "#cf1919")) + 
      xlab("Tissue") + 
      ylab("Allele Frequency") +
      labs(fill = "Genotype", col = "Genotype") +
      theme_bw(20) +
      theme(strip.text.x = element_text(size = 12)) +
      theme(axis.title.x=element_blank()) +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
      theme(legend.position="bottom")

```


```{r Write out the SNP backgrounds, echo=F}

# Write out to assigned file. 
print(paste("Writing the results to", output.path))
write_csv(assigned.df, output.path)

```


