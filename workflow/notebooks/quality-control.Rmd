---
title: "1. Quality Control"
author:
    - "Will Hannon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
---

The goal of this notebook is to determine the quality of the variant calling data. What is the overlap between the different variant callers? How much coverage do we have in each sample? Are there samples that are problematic in some way?

```{r Setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = FALSE)
```

```{r Required Packages, message=FALSE, warning=FALSE}

## ==== Install Required Packages ==== ##

## List of all packages needed

packages = c("tidyverse", "UpSetR")
# ## Check that packages are installed, if not, install them
# installed_packages <- packages %in% rownames(installed.packages())
# if (any(installed_packages == FALSE)) {
#   
#   install.packages(packages[!installed_packages])
# }
# ## Packages loading
invisible(lapply(c(packages), library, character.only = TRUE))

```

```{r Inputs, echo=T}

## ==== File paths input data ==== ##

# Variant data parsed from from lofreq, ivar, and varscan VCFs
# variant.data = "../../results/variants/variants.csv"

variant.data = snakemake@input[[1]]

```

```{r Outputs, echo=T}

## ==== File paths output data ==== ##

# Path to save the figures for lab meeting 
# output.path = "../../results/variants/filtered_variants.csv"

output.path = snakemake@params[["outcsv"]]

# if (!dir.exists(output.path)) {
#   dir.create(file.path(output.path), showWarnings = FALSE)
# }

```

## Processing the variant data

I used three different variant callers to identify mutations in the measles virus genome. In the absence of biological replicates, this is a way to control for issues in the variant calling pipelines that could result in spurious variants. In addition to these different variant calling approaches, I've set a cutoff of `200X coverage` and a minimum allele frequency of `2% of reads`. 

To identify a set of mutations to go forward with, I'll combine the mutations from each variant caller and control for SNPs that might be lower frequency in a single sample due to low coverage. 

```{r Process Data, warning=F, message=F, echo=T}

# Minimum allele frequency to be included in analysis. 
min_AF = 0.02
# Minimum read depth to be included in analysis. 
min_DP = 200

# Import lofreq data and filter
lofreq.variant.df = read_csv(variant.data, show_col_types = FALSE) %>% 
  filter(Caller == 'lofreq') %>% 
  mutate(SNP = paste0(REF, POS, ALT)) %>% 
  mutate(Type = case_when(nchar(REF) > 1 ~ "Del",
                          nchar(ALT) > 1 ~ "Ins",
                          nchar(REF) == 1 ~ "SNP")) %>% 
  filter(Type == "SNP") %>% 
  filter(DP >= min_DP) %>% 
  filter(AF >= min_AF)

# Import ivar data and filter 
ivar.variant.df = read_csv(variant.data, show_col_types = FALSE) %>% 
  filter(Caller == 'ivar') %>% 
  mutate(SNP = paste0(REF, POS, ALT)) %>% 
  mutate(Type = case_when(nchar(REF) > 1 ~ "Del",
                          nchar(ALT) > 1 ~ "Ins",
                          nchar(REF) == 1 ~ "SNP")) %>% 
  filter(Type == "SNP") %>% 
  filter(DP >= min_DP) %>% 
  filter(AF >= min_AF)

# Import lofreq data and filter 
varscan.variant.df = read_csv(variant.data, show_col_types = FALSE) %>% 
  filter(Caller == 'varscan') %>% 
  mutate(SNP = paste0(REF, POS, ALT)) %>% 
  mutate(Type = case_when(nchar(REF) > 1 ~ "Del",
                          nchar(ALT) > 1 ~ "Ins",
                          nchar(REF) == 1 ~ "SNP")) %>% 
  filter(Type == "SNP") %>% 
  filter(DP >= min_DP) %>% 
  filter(AF >= min_AF)

```

Comfortingly, there is a large overlap between the variants called in the three approaches. I will take the intersection of these three approaches for the downstream analysis.

```{r Caller Comparison, fig.align='center', fig.width=10, fig.height=5}

combined.variants.df = rbind(
  
mutate(lofreq.variant.df, Approach = "lofreq"),

mutate(varscan.variant.df, Approach = "varscan"), 

mutate(ivar.variant.df, Approach = "ivar")

)

combined.variants.df %>% 
  mutate(Identifier = paste(Tissue, SNP, sep = "-")) %>% 
  select(Identifier, Approach) %>% 
  distinct() %>% 
  mutate(Tally = 1) %>% 
  pivot_wider(names_from = "Approach", values_from = "Tally", values_fill = 0) %>% 
  as.data.frame(row.names = Identifier) %>%
  upset(., sets = c("lofreq",
                          "varscan",
                          "ivar"), sets.bar.color = "#56B4E9",
      order.by = "freq", empty.intersections = "on", text.scale = 1.5)


```

For the final set of trusted variants I'm going to ignore `ivar`. I've found that this variant caller sometimes produces unexpected annotations.

Some mutations appear in both the `varscan` and `lofreq` data sets, but are present in one particular tissue in one approach and absent from that same tissue in another. These are likely real variants that are missed by one approach due a particular filter. I'll correct for this by resolving the mutations are called by both approaches in some tissues, but missing from one approach in a specific tissue. I'll write these out to a file for other analyses (`final_variants.csv`). 

```{r Get final set of variants, message=F, warning=F, echo=T}

# Total unique variants called in both lofreq and varscan
total.variants = combined.variants.df %>% 
  filter(Caller != "ivar") %>% # Not considering `ivar`
  select(SNP, Caller) %>% 
  distinct() %>% 
  group_by(SNP) %>% 
  count() %>% 
  filter(n == 2) %>% 
  pull(SNP)


# Then, I'll figure out how many of these are missing in a specific tissue in one method
missing.from.one = combined.variants.df %>% 
  filter(Caller != "ivar") %>% 
  filter(SNP %in% total.variants) %>% 
  select(SNP, Accession, Caller) %>% 
  group_by(SNP, Accession) %>% 
  count() %>% 
  filter(n < 2)

print(paste("There are", length(unique(pull(missing.from.one, SNP))), "instances in which one variant caller picks up on a mutation that's missing from the other."))


# High-quality SNPs that are missing from one method in a given tissue
snps.to.resolve = missing.from.one %>% 
  select(SNP, Accession) %>% 
  mutate(resolve_ID = paste(SNP, Accession, sep = "-")) %>% 
  pull(resolve_ID)


# Most are in lofreq and missing from varscan. I'll add these to the varscan data.
missing.snps.from.varscan = combined.variants.df %>% 
  mutate(resolve_ID = paste(SNP, Accession, sep = "-")) %>% 
  filter(resolve_ID %in% snps.to.resolve) %>% 
  filter(Caller == "lofreq") %>% 
  select(!resolve_ID)


# Added to the varscan data. 
selected.variants.df = combined.variants.df %>% 
  filter(Caller == "varscan") %>% 
  rbind(., missing.snps.from.varscan) %>% 
  select(!c("Caller", "Virus", "Host", "R1", "R2", "Type", "Sample", "Approach")) 


print(paste("In total, there are", length(unique(pull(selected.variants.df, SNP))), "unqiue SNPs in the brain."))

```

```{r Write out selected variants, echo=T}

print(paste("Writing out the results to", output.path))

# write_csv(selected.variants.df, paste(output.path, "filtered_variants.csv", sep = "/"))

write_csv(selected.variants.df, output.path)

```

